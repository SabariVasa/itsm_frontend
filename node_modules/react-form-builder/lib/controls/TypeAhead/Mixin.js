"use strict";

var TypeAheadMixin, clone, contains, debounce, isEmpty, isObject;

isEmpty = require("lodash/isEmpty");

contains = require("lodash/includes");

debounce = require("lodash/debounce");

clone = require("lodash/clone");

isObject = require("lodash/isObject");

TypeAheadMixin = {
  getInitalState: function getInitalState() {
    return {
      lastOptions: []
    };
  },
  onBlur: function onBlur(event) {
    var nextState;
    if (this.props.free) {
      this.props.onDataChanged(this.props.dataKey, event.target.value);
    }
    nextState = {
      options: [],
      lastOptions: this.state.options,
      hiddenList: true,
      highlightedIndex: -1
    };
    if (!isEmpty(this.state.options)) {
      nextState.lastOptions = this.state.options;
    }
    return this.setState(nextState);
  },
  onKeyDown: function onKeyDown(event) {
    var key;
    key = event.key;
    if (contains(["Return", "Enter", "ArrowDown", "ArrowUp"], key)) {
      event.preventDefault();
      return event.stopPropagation();
    }
  },
  onKeyUp: function onKeyUp(event) {
    var i;
    switch (event.key) {
      case "Return":
      case "Enter":
        if (this.state.highlightedIndex >= 0) {
          this.selectItem(this.state.options[this.state.highlightedIndex]);
        } else if (this.state.options.length === 1) {
          this.selectItem(this.state.options[0]);
        } else if (this.state.options.length === 0 && this.state.lastOptions.length === 1) {
          this.selectItem(this.state.lastOptions[0]);
        }
        break;
      case "ArrowDown":
        i = this.state.highlightedIndex;
        if (i < this.state.options.length - 1) {
          i += 1;
        }
        this.setState({
          highlightedIndex: i
        });
        break;
      case "ArrowUp":
        i = this.state.highlightedIndex;
        if (i > -1) {
          i -= 1;
        }
        this.setState({
          highlightedIndex: i
        });
        break;
      case "Escape":
        this.setState({
          hiddenList: true
        });
        break;
      default:
        this.setState({
          hiddenList: false
        });
        this.pendingStringChange = event.target.value;
        this.debouncedOnKeyUp();
    }
    event.preventDefault();
    return event.stopPropagation();
  },
  debouncedOnKeyUp: debounce(function () {
    var dependencies, string;
    string = this.pendingStringChange;
    delete this.pendingStringChange;
    this.setState({
      highlightedIndex: -1,
      options: [],
      hiddenList: false
    });
    dependencies = clone(this.props.dependencies);
    dependencies[this.props.dataKey + "_typeahead"] = string;
    return this.loadDataSource("options", dependencies);
  }, 100),
  formattedItem: function formattedItem() {
    if (isObject(this.state.item)) {
      return this.state.item;
    } else {
      return {
        value: this.state.item,
        displayName: this.state.item
      };
    }
  },
  renderLabel: function renderLabel() {
    if (this.props.displayName !== false) {
      return React.createElement(
        "label",
        { className: "col-sm-2 control-label", htmlFor: this.props.dataKey },
        this.props.displayName
      );
    }
  }
};

module.exports = TypeAheadMixin;