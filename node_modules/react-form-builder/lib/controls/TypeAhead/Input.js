"use strict";

var DataTypeConversionMixin, Input, React, ReactBootstrap, SingleInputMixin, classnames, isEqual;

React = require("react");

classnames = require("classnames");

SingleInputMixin = require("../mixins/SingleInput");

ReactBootstrap = require("react-bootstrap");

DataTypeConversionMixin = require("../mixins/DataTypeConversion");

isEqual = require("lodash/isEqual");

Input = React.createClass({
  displayName: "Input",

  mixins: [SingleInputMixin, DataTypeConversionMixin],
  propTypes: {
    item: React.PropTypes.object.isRequired,
    emptyList: React.PropTypes.bool.isRequired,
    dataKey: React.PropTypes.string.isRequired,
    free: React.PropTypes.bool,
    loading: React.PropTypes.bool,
    disabled: React.PropTypes.bool,
    placeholder: React.PropTypes.bool,
    title: React.PropTypes.string,
    onChange: React.PropTypes.func,
    onFocus: React.PropTypes.func,
    onBlur: React.PropTypes.func,
    onKeyDown: React.PropTypes.func,
    onKeyUp: React.PropTypes.func
  },
  getInitialState: function getInitialState() {
    var ref;
    return {
      displayText: (ref = this.props.item.displayName) != null ? ref : void 0
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.clearCount !== this.props.clearCount) {
      return this.setState({
        displayText: null
      });
    } else if (nextProps.item && !isEqual(nextProps.item, this.props.item)) {
      return this.setState({
        displayText: nextProps.item.displayName
      });
    }
  },
  renderInputIcon: function renderInputIcon() {
    var classes;
    classes = classnames({
      "form-control-feedback": true,
      "autocomplete-feedback": true
    });
    if (this.props.loading) {
      return React.createElement(
        "span",
        { className: classes },
        React.createElement(ReactBootstrap.Glyphicon, { glyph: "refresh" })
      );
    } else if (this.state.displayText === void 0 || this.state.displayText === null || !this.props.emptyList) {
      return React.createElement(
        "span",
        { className: classes },
        React.createElement(ReactBootstrap.Glyphicon, { glyph: "search" })
      );
    } else if (this.itemValue() && this.state.displayText !== "") {
      return React.createElement(
        "span",
        { className: classes },
        React.createElement(ReactBootstrap.Glyphicon, { glyph: "ok" })
      );
    } else {
      return React.createElement(
        "span",
        { className: classes },
        React.createElement(ReactBootstrap.Glyphicon, { glyph: "warning-sign" })
      );
    }
  },
  itemValue: function itemValue() {
    if (this.props.free || this.props.item.displayName === this.state.displayText) {
      return this.state.displayText;
    }
  },
  onChange: function onChange(event) {
    var base;
    this.setState({
      displayText: this.convertDataType(event.target.value)
    });
    return typeof (base = this.props).onChange === "function" ? base.onChange(this.convertDataType(event.target.value)) : void 0;
  },
  render: function render() {
    return React.createElement(
      "div",
      null,
      React.createElement("input", {
        type: "hidden",
        name: this.props.dataKey,
        value: this.itemValue()
      }),
      React.createElement("input", {
        autoComplete: "off",
        className: "form-control",
        type: "search",
        name: this.props.dataKey + "_helper",
        disabled: this.props.disabled,
        placeholder: this.props.placeholder,
        value: this.state.displayText,
        title: this.props.title,
        onChange: this.onChange,
        onFocus: this.props.onFocus,
        onBlur: this.props.onBlur,
        onKeyDown: this.props.onKeyDown,
        onKeyUp: this.props.onKeyUp
      }),
      this.renderInputIcon(),
      this.props.children
    );
  }
});

module.exports = Input;