"use strict";

var DataSourcedMixin, React, capitalize, clone, difference, each, keys, shallowEqual, tap;

React = require("react");

shallowEqual = require("shallowequal");

tap = require("lodash/tap");

keys = require("lodash/keys");

difference = require("lodash/difference");

clone = require("lodash/clone");

each = require("lodash/each");

capitalize = require("lodash/capitalize");

DataSourcedMixin = {
  propTypes: {
    dataSources: React.PropTypes.object.isRequired
  },
  getInitialState: function getInitialState() {
    return tap({}, (function (_this) {
      return function (state) {
        var dataSource, name, ref, results;
        ref = _this.props.dataSources;
        results = [];
        for (name in ref) {
          dataSource = ref[name];
          state[_this.loadingStateKey(name)] = false;
          if ("initial" in dataSource) {
            results.push(state[name] = dataSource.initial);
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
    })(this));
  },
  componentDidMount: function componentDidMount() {
    var dataSource, name, ref, results;
    ref = this.props.dataSources;
    results = [];
    for (name in ref) {
      dataSource = ref[name];
      results.push(this.loadDataSource(name, this.props.dependencies));
    }
    return results;
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var dataSource, name, ref, results;
    ref = this.props.dataSources;
    results = [];
    for (name in ref) {
      dataSource = ref[name];
      if (dataSource.dependentKeys != null && dataSource.type === "service" && !shallowEqual(nextProps.dependencies, this.props.dependencies)) {
        results.push(this.loadDataSource(name, nextProps.dependencies));
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  loadDataSource: function loadDataSource(dataSourceName, dependencies) {
    var dataSource, missingDependencies, ref;
    dataSource = this.props.dataSources[dataSourceName];
    switch (dataSource.type) {
      case "service":
        missingDependencies = difference(dataSource.dependentKeys, keys(dependencies));
        if (missingDependencies.length > 0) {} else {
          return this.handleService(dataSourceName, this.tokenizeArgs(dependencies, (ref = dataSource.args) != null ? ref : []));
        }
        break;
      case "inline":
        return this.updateDataSource(dataSourceName, dataSource.data);
      default:
        throw new Error("dataSource.type " + dataSource.type + " is not a valid data source.");
    }
  },
  updateDataSource: function updateDataSource(dataSourceName, data) {
    var update;
    update = {};
    update[dataSourceName] = this.applyAdapter(this.props.dataSources[dataSourceName], data);
    return this.setState(update);
  },
  handleService: function handleService(dataSourceName, args) {
    var dataSource;
    dataSource = this.props.dataSources[dataSourceName];
    return this.loadingDataSource(dataSourceName, (function (_this) {
      return function () {
        var options;
        options = {
          complete: function complete() {
            if (_this.isMounted()) {
              return _this.doneLoadingDataSource(dataSourceName);
            }
          },
          success: function success(resp) {
            if (_this.isMounted()) {
              return _this.updateDataSource(dataSourceName, resp);
            }
          }
        };
        if (args.length > 0) {
          return dataSource.service(args, options);
        } else {
          return dataSource.service(options);
        }
      };
    })(this));
  },
  loadingStateKey: function loadingStateKey(dataSourceName) {
    return "loading" + capitalize(dataSourceName);
  },
  loadingDataSource: function loadingDataSource(dataSourceName, cb) {
    var update;
    update = {};
    update[this.loadingStateKey(dataSourceName)] = true;
    return this.setState(update, cb);
  },
  doneLoadingDataSource: function doneLoadingDataSource(dataSourceName) {
    var update;
    update = {};
    update[this.loadingStateKey(dataSourceName)] = false;
    return this.setState(update);
  },
  applyAdapter: function applyAdapter(dataSource, data) {
    if (dataSource.adapter) {
      return dataSource.adapter(data);
    } else {
      return data;
    }
  },

  /*
    This will loop through the service args list pulling out values that are of the form:
      ${dependent_key}
    and replacing them with the associated value for that dependent key. Ex:
  
      Data source in the form defintion:
  
        dataSources: {
          options {
            dependentKeys: ['customer_id', 'job_id', 'campaign_id']
            args: ['${campaign_id}', '${customer_id}', '${job_id}', 66]
            ...
          }
        }
  
      Dependencies hash passed into the component:
  
        {
          customer_id: 44,
          job_id: 123,
          campaign_id: 99
        }
  
      Results in the following args list:
  
        [99, 44, 123, 66]
   */
  tokenizeArgs: function tokenizeArgs(dependencies, args) {
    var tokenizedArgs;
    tokenizedArgs = clone(args);
    each(args, (function (_this) {
      return function (argument, index) {
        var key;
        if (typeof argument === "string" && argument.substr(0, 2) === "${") {
          key = argument.substr(2, argument.length - 3);
          return tokenizedArgs[index] = dependencies[key];
        } else {
          return tokenizedArgs[index] = argument;
        }
      };
    })(this));
    return tokenizedArgs;
  }
};

module.exports = DataSourcedMixin;