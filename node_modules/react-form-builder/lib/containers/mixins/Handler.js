"use strict";

var Form, HandlerMixin, React, clone, each, extend, isEmpty, isEqual;

React = require("react");

Form = require("../Form");

isEqual = require("lodash/isEqual");

each = require("lodash/each");

extend = require("lodash/assign");

clone = require("lodash/clone");

isEmpty = require("lodash/isEmpty");

HandlerMixin = {
  propTypes: {
    title: React.PropTypes.string,
    submitting: React.PropTypes.bool,
    serverErrors: React.PropTypes.object,
    formData: React.PropTypes.object,
    buttons: React.PropTypes.object,
    errorResponseHandler: React.PropTypes.object
  },
  getInitialState: function getInitialState() {
    var ref, ref1, ref2, ref3, ref4, ref5;
    return {
      title: (ref = this.props.title) != null ? ref : "",
      submitting: (ref1 = this.props.submitting) != null ? ref1 : false,
      serverErrors: (ref2 = this.props.serverErrors) != null ? ref2 : null,
      formData: (ref3 = this.props.formData) != null ? ref3 : {},
      formDef: (ref4 = this.props.formDef) != null ? ref4 : {},
      buttons: this.bindButtons((ref5 = this.props.buttons) != null ? ref5 : this.defaultButtons())
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (!isEqual(nextProps.formData, this.props.formData)) {
      if (this.isMounted()) {
        return this.setState({
          formData: nextProps.formData
        });
      }
    }
  },
  defaultButtons: function defaultButtons() {
    return {
      Save: {
        onClick: "submitForm",
        bsStyle: "primary"
      },
      Reset: {
        onClick: "resetForm",
        bsStyle: "warning"
      },
      Cancel: {
        onClick: "cancelForm"
      }
    };
  },
  bindButtons: function bindButtons(buttons) {
    var boundButtons;
    boundButtons = {};
    each(buttons, (function (_this) {
      return function (value, key) {
        return boundButtons[key] = extend(clone(value), {
          onClick: _this[value.onClick]
        });
      };
    })(this));
    return boundButtons;
  },
  setForm: function setForm(formData) {
    if (this.isMounted()) {
      return this.setState({
        formData: formData,
        submitting: false
      });
    }
  },
  submitForm: function submitForm() {
    if (this.isMounted()) {
      return this.setState({
        submitting: true
      }, (function (_this) {
        return function () {
          return _this.onSubmit(function () {
            return _this.setState({
              submitting: false
            });
          });
        };
      })(this));
    }
  },
  setServerErrors: function setServerErrors(response) {
    if (response.status === 422) {
      if (this.isMounted()) {
        return this.setState({
          serverErrors: response.body,
          submitting: false
        });
      }
    } else {
      if (this.isMounted()) {
        this.setState({
          submitting: false
        });
        return this.props.errorResponseHandler.resolve(response);
      }
    }
  },
  clearForm: function clearForm() {
    if (this.isMounted()) {
      return this.setState({
        formData: this.props.formData,
        submitting: false
      });
    }
  },
  resetForm: function resetForm() {
    if (this.isMounted()) {
      return this.setState({
        formData: this.props.formData
      });
    }
  },
  cancelForm: function cancelForm() {
    if (this.onCancel) {
      return this.onCancel();
    } else {
      return this.goBackHistory();
    }
  },
  goBackHistory: function goBackHistory() {
    return window.history.back();
  },
  renderForm: function renderForm(options) {
    var form;
    if (options == null) {
      options = {};
    }
    form = React.createElement(Form, {
      title: this.state.title,
      formDef: this.state.formDef,
      formData: this.state.formData,
      serverErrors: this.state.serverErrors,
      buttons: this.state.buttons,
      submitting: this.state.submitting || this.state.loading,
      onDataChanged: this.onDataChanged,
      onEnter: this.submitForm
    });
    if (isEmpty(options)) {
      return form;
    } else {
      return React.cloneElement(form, options);
    }
  },
  onDataChanged: function onDataChanged(dataKey, value) {
    var datum, i, len, newData, part, parts, results;
    if (this.isMounted()) {
      newData = clone(this.state.formData || {});
      datum = newData;
      parts = dataKey.split(".");
      for (i = 0, len = parts.length; i < len; i++) {
        part = parts[i];
        results = part.match(/^([a-zA-Z_]+)\[(\d)+\]$/);
        if (part !== parts[parts.length - 1]) {
          if (results) {
            datum = datum[results[1]][results[2]];
          } else {
            datum = datum[part];
          }
        } else {
          if (results) {
            datum[results[1]][results[2]] = value;
          } else {
            datum[part] = value;
          }
        }
      }
      return this.setState({
        formData: newData
      });
    }
  }
};

module.exports = HandlerMixin;