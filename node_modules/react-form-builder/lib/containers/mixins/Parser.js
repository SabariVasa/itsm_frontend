"use strict";

var Containers, Controls, ParserMixin, React, clone, compact, each, extend, map, tap;

React = require("react");

Controls = require("../../controls/Controls");

Containers = require("../Containers");

extend = require("lodash/assign");

map = require("lodash/map");

clone = require("lodash/clone");

each = require("lodash/each");

tap = require("lodash/tap");

compact = require("lodash/compact");

ParserMixin = {
  propTypes: {
    formDef: React.PropTypes.object.isRequired,
    formData: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.array]),
    title: React.PropTypes.string
  },
  getDefaultProps: function getDefaultProps() {
    return {
      formDef: {},
      formData: {}
    };
  },
  getInitialState: function getInitialState() {
    if (this.props.formData) {
      return {
        formData: this.props.formData
      };
    } else {
      return {
        formData: {}
      };
    }
  },
  constructFormFromDef: function constructFormFromDef(def, base) {
    return def.components.map((function (_this) {
      return function (def) {
        var data, type;
        type = def.type;
        if (type === void 0) {
          throw new Error("No form component type defined.");
        }
        data = _this.resolveData(_this.generateDataKey(def.dataKey, base));
        switch (type) {
          case "form-group":
            return _this.formGroup(def, base);
          case "input-group":
            return _this.inputGroup(def, base);
          case "dynamic-def":
            return _this.dynamicDefinition(def, base);
          case "nested-form-group":
            return _this.nestedFormGroup(def, base);
          case "nested-field-group":
            return _this.nestedFieldGroup(def, data, base);
          case "markdown-field":
            return _this.markdown(def, data, base);
          case "hidden-field":
            return _this.hidden(def, data, base);
          case "text-field":
            return _this.text(def, data, base);
          case "file-text-field":
            return _this.fileText(def, data, base);
          case "number-field":
            return _this.number(def, data, base);
          case "drop-down":
            return _this.dropDown(def, data, base);
          case "multiple-select":
            return _this.multipleSelect(def, data, base);
          case "date-field":
            return _this.date(def, data, base);
          case "date-time-field":
            return _this.dateTime(def, data, base);
          case "password-field":
            return _this.password(def, data, base);
          case "text-area":
            return _this.textArea(def, data, base);
          case "radio-buttons":
            return _this.radioButtons(def, data, base);
          case "checkbox":
            return _this.checkBox(def, data, base);
          case "file-select":
            return _this.file(def, data, base);
          case "type-ahead-field":
            return _this.typeAhead(def, data, base);
          case "multi-type-ahead-field":
            return _this.multiTypeAhead(def, data, base);
          default:
            throw new Error("Unknown form component " + type);
        }
      };
    })(this));
  },
  formGroup: function formGroup(def, base) {
    var dataKey;
    dataKey = this.generateDataKey(def.dataKey, base);
    return React.createFactory(Containers.Group)({
      dataKey: dataKey,
      formDef: def,
      title: def.title,
      formData: this.props.formData,
      serverErrors: this.props.serverErrors,
      submitting: this.props.submitting,
      onDataChanged: this.props.onDataChanged,
      onEnter: this.props.onEnter,
      key: def.type + "-" + dataKey
    }, this.constructFormFromDef(def, base));
  },
  inputGroup: function inputGroup(def, base) {
    var dataKey;
    dataKey = this.generateDataKey(def.dataKey, base);
    return React.createFactory(Containers.InputGroup)({
      dataKey: this.generateDataKey(dataKey, base),
      formDef: def,
      formData: this.props.formData,
      serverErrors: this.props.serverErrors,
      submitting: this.props.submitting,
      onDataChanged: this.props.onDataChanged,
      onEnter: this.props.onEnter,
      key: def.type + "-" + dataKey,
      leftComponent: def.leftComponent ? this.constructFormFromDef(def.leftComponent, base) : null,
      rightComponent: def.rightComponent ? this.constructFormFromDef(def.rightComponent, base) : null,
      mainComponent: def.mainComponent ? this.constructFormFromDef(def.mainComponent, base) : null
    });
  },
  dynamicDefinition: function dynamicDefinition(def, base) {
    var dataKey, dynDef;
    dataKey = this.generateDataKey(def.dataKey, base);
    dynDef = this.resolveData(dataKey);
    return React.createFactory(Containers.DynamicDefinition)({
      dataKey: dataKey,
      formDef: def,
      title: def.title,
      formData: this.props.formData,
      serverErrors: this.props.serverErrors,
      submitting: this.props.submitting,
      onDataChanged: this.props.onDataChanged,
      onEnter: this.props.onEnter,
      dataSources: def.dataSources,
      dependencies: this.parseDependencies(def)
    }, dynDef ? this.constructFormFromDef(dynDef, base) : null);
  },
  hidden: function hidden(def, data, base) {
    return React.createFactory(Controls.Hidden)(this.standardProps(def, data, base));
  },
  text: function text(def, data, base) {
    return React.createFactory(Controls.Text)(this.standardProps(def, data, base));
  },
  fileText: function fileText(def, data, base) {
    return React.createFactory(Controls.FileText)(extend(this.standardProps(def, data, base), {
      fileDestinationService: def.fileDestinationService
    }));
  },
  number: function number(def, data, base) {
    return React.createFactory(Controls.Number)(this.standardProps(def, data, base));
  },
  date: function date(def, data, base) {
    return React.createFactory(Controls.Date)(this.standardProps(def, data, base));
  },
  dateTime: function dateTime(def, data, base) {
    return React.createFactory(Controls.DateTime)(extend(this.standardProps(def, data, base), {
      direction: def.direction
    }));
  },
  password: function password(def, data, base) {
    return React.createFactory(Controls.Password)(this.standardProps(def, data, base));
  },
  textArea: function textArea(def, data, base) {
    return React.createFactory(Controls.TextArea)(extend(this.standardProps(def, data, base), {
      rows: def.rows
    }));
  },
  checkBox: function checkBox(def, data, base) {
    return React.createFactory(Controls.Checkbox)(this.standardProps(def, data, base));
  },
  markdown: function markdown(def, data, base) {
    return React.createFactory(Controls.Markdown)(extend(this.standardProps(def, data, base), {
      fileDestinationService: def.fileDestinationService
    }));
  },
  file: function file(def, data, base) {
    return React.createFactory(Controls.File)(extend(this.standardProps(def, data, base), {
      dragAndDrop: def.dragAndDrop,
      onFileSelect: def.onFileSelect
    }));
  },
  dropDown: function dropDown(def, data, base) {
    return React.createFactory(Controls.Dropdown)(extend(this.standardProps(def, data, base), {
      dataSources: def.dataSources,
      dependencies: this.parseDependencies(def)
    }));
  },
  multipleSelect: function multipleSelect(def, data, base) {
    return React.createFactory(Controls.MultiSelect)(extend(this.standardProps(def, data, base), {
      dataSources: def.dataSources,
      dependencies: this.parseDependencies(def)
    }));
  },
  radioButtons: function radioButtons(def, data, base) {
    return React.createFactory(Controls.RadioButtons)(extend(this.standardProps(def, data, base), {
      boolean: def.boolean,
      dataSources: def.dataSources,
      dependencies: this.parseDependencies(def)
    }));
  },
  typeAhead: function typeAhead(def, data, base) {
    return React.createFactory(Controls.TypeAhead)(extend(this.standardProps(def, data, base), {
      dataSources: def.dataSources,
      dependencies: this.parseDependencies(def),
      free: def.free
    }));
  },
  multiTypeAhead: function multiTypeAhead(def, data, base) {
    return React.createFactory(Controls.MultiTypeAhead)(extend(this.standardProps(def, data, base), {
      dataSources: def.dataSources,
      dependencies: this.parseDependencies(def),
      free: def.free
    }));
  },
  nestedFormGroup: function nestedFormGroup(def, data, base) {
    var dataKey;
    dataKey = this.generateDataKey(def.dataKey, base);
    return React.createFactory(Controls.NestedFormGroup)({
      dataKey: dataKey,
      formDef: def,
      formData: this.props.formData,
      title: def.title,
      serverErrors: this.props.serverErrors,
      submitting: this.props.submitting,
      addNestedForm: this.addNestedForm(dataKey),
      onDataChanged: this.props.onDataChanged,
      onEnter: this.props.onEnter
    }, map(this.resolveData(dataKey), (function (_this) {
      return function (data, nestedIndex) {
        var ref, ref1;
        return React.createFactory(Containers.Group)({
          title: def.nestedTitle,
          dataKey: dataKey + "[" + nestedIndex + "]",
          formDef: (ref = def.nestedFormDef) != null ? ref : def,
          formData: _this.props.formData,
          serverErrors: _this.props.serverErrors,
          submitting: _this.props.submitting,
          onDataChanged: _this.props.onDataChanged,
          onEnter: _this.props.onEnter,
          removeNestedForm: _this.removeNestedForm(nestedIndex, dataKey)
        }, _this.constructFormFromDef((ref1 = def.nestedFormDef) != null ? ref1 : def, dataKey + "[" + nestedIndex + "]"));
      };
    })(this)));
  },
  removeNestedForm: function removeNestedForm(nestedIndex, parentDataKey) {
    return (function (_this) {
      return function (dataKey) {
        var newData;
        nestedIndex = dataKey.match(/^([a-zA-Z_]+)\[(\d)+\]$/)[2];
        newData = clone(_this.resolveData(parentDataKey));
        newData.splice(nestedIndex, 1);
        return _this.props.onDataChanged(parentDataKey, newData);
      };
    })(this);
  },
  addNestedForm: function addNestedForm(dataKey) {
    return (function (_this) {
      return function () {
        var newData;
        newData = clone(_this.resolveData(dataKey));
        newData.push({});
        return _this.props.onDataChanged(dataKey, newData);
      };
    })(this);
  },
  nestedFieldGroup: function nestedFieldGroup(def, data, base) {
    return React.createFactory(Controls.NestedFieldGroup)({
      displayName: def.displayName,
      dataKey: this.generateDataKey(def.dataKey, base),
      formDef: def,
      formData: this.props.formData,
      nestedType: def.nestedType,
      disabled: def.disabled,
      title: def.title,
      serverErrors: this.props.serverErrors,
      submitting: this.props.submitting,
      onDataChanged: this.props.onDataChanged,
      onEnter: this.props.onEnter,
      key: this.generateDataKey(def.dataKey, base),
      data: data != null ? data : []
    });
  },
  resolveData: function resolveData(dataKey, data) {
    var j, len, part, parts, results;
    if (data == null) {
      data = this.props.formData;
    }
    if (!dataKey) {
      return null;
    }
    parts = dataKey.split(".");
    for (j = 0, len = parts.length; j < len; j++) {
      part = parts[j];
      results = part.match(/^([a-zA-Z_]*)\[(\d)+\]$/);
      if (results) {
        if (results[1]) {
          data = data[results[1]];
        }
        if (results[2]) {
          data = data[results[2]];
        }
      } else {
        data = data[part];
      }
    }
    return data;
  },
  generateDataKey: function generateDataKey(dataKey, base) {
    if (base == null) {
      base = null;
    }
    return compact([base, dataKey]).join(".");
  },
  parseDependencies: function parseDependencies(def) {
    return tap({}, (function (_this) {
      return function (dependencies) {
        var dataSource, name, ref, ref1, ref2, results1;
        ref1 = (ref = def.dataSources) != null ? ref : [];
        results1 = [];
        for (name in ref1) {
          dataSource = ref1[name];
          results1.push(each((ref2 = dataSource.dependentKeys) != null ? ref2 : [], function (dataKey, i) {
            if (_this.props.formData[dataKey] !== void 0) {
              return dependencies[dataKey] = _this.props.formData[dataKey];
            }
          }));
        }
        return results1;
      };
    })(this));
  },
  standardProps: function standardProps(def, data, base) {
    return {
      key: def.type + "-" + def.dataKey,
      data: data,
      dataType: def.dataType,
      displayName: def.displayName,
      dataKey: this.generateDataKey(def.dataKey, base),
      serverErrors: this.props.serverErrors,
      submitting: this.props.submitting,
      placeholder: def.placeholder,
      title: def.title,
      validators: def.validators,
      onDataChanged: this.props.onDataChanged,
      onEnter: this.props.onEnter,
      helpText: def.helpText,
      disabled: def.disabled
    };
  }
};

module.exports = ParserMixin;